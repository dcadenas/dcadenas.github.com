<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Testing | Daniel Cadenas]]></title>
  <link href="http://dcadenas.github.com/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://dcadenas.github.com/"/>
  <updated>2012-03-18T03:57:59-03:00</updated>
  <id>http://dcadenas.github.com/</id>
  <author>
    <name><![CDATA[Daniel Cadenas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mocha_mock_path error in your tests]]></title>
    <link href="http://dcadenas.github.com/blog/2008/09/26/mochamockpath-error-in-your-tests/"/>
    <updated>2008-09-26T12:29:00-03:00</updated>
    <id>http://dcadenas.github.com/blog/2008/09/26/mochamockpath-error-in-your-tests</id>
    <content type="html"><![CDATA[<p>If you use stubs in your Mocha tests but they break because of this error:</p>

<p><code>
ActionView::TemplateError: undefined method `mocha_mock_path'
</code></p>

<p>Check that you also stub the <code>class</code> method.</p>

<p><code>ruby
stub(:title =&gt; 'a title', :class =&gt; News)
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stubbing/Mocking constants with Mocha]]></title>
    <link href="http://dcadenas.github.com/blog/2008/09/10/stubbingmocking-constants-with-mocha/"/>
    <updated>2008-09-10T12:34:00-03:00</updated>
    <id>http://dcadenas.github.com/blog/2008/09/10/stubbingmocking-constants-with-mocha</id>
    <content type="html"><![CDATA[<p>As far as google told me, it seems you can't use Mocha against constants.</p>

<p>One alternative <a href="http://rubyforge.org/pipermail/mocha-developer/2007-July/000394.html">proposed</a> is changing the constant in the test where you need it like these:</p>

<p>```ruby
class Module
   def redefine_const(name, value)</p>

<pre><code> __send__(:remove_const, name) if const_defined?(name)
 const_set(name, value)
</code></pre>

<p>   end
end
```</p>

<p>And inside the test case you change the constant to what you need and restore it after the test ends:</p>

<p><code>ruby
Object.redefine_const(:RAILS_ENV, 'production')
</code></p>

<p>But if you can control the code that uses the constant there's a more clean way. Just wrap it in a method and get the constant through the method. During testing you just mock the method:</p>

<p>```ruby
class A
  def rails_env</p>

<pre><code>RAILS_ENV
</code></pre>

<p>  end
  #...some more code that gets the constant RAILS_ENV using the method rails_env...
end
```</p>

<p>And then in your test you just do a normal expectation:</p>

<p><code>ruby
A.any_instance.expects(:rails_env).returns 'production'
</code></p>

<p>You could even have some module that wraps all useful constants in your app, so constant dependent code gets easily testable and clean.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A file system integration tests helper]]></title>
    <link href="http://dcadenas.github.com/blog/2008/03/04/file-system-integration-tests-helper/"/>
    <updated>2008-03-04T20:50:00-02:00</updated>
    <id>http://dcadenas.github.com/blog/2008/03/04/file-system-integration-tests-helper</id>
    <content type="html"><![CDATA[<p>A common problem that arises when creating integration tests against the file system is not having a one on one mapping between test cases and file structures.</p>

<p>The most popular solution is having one generic file structure defined outside the test case (manually or in the test fixture set up) in which a generic set of files are shared among many different test cases.</p>

<p>This works, but the problem is that we lose a lot of the documenting benefit of tests.</p>

<p>The expressive power we could gain by the explicit creation of customized test files for each test case is very important.</p>

<p>Of course we should test all we can inside our unit tests but it's always good to have something in our toolbox in case we have to go to the real thing at some moment.</p>

<p>One example is when you have to deal with highly coupled legacy code in which your only practical solution may be testing directly against it's file inputs and outputs.</p>

<p>So considering all this I made a very simple ruby gem, <a href="http://filetesthelper.rubyforge.org/">filetesthelper</a>, that let's you do something like this:</p>

<p>```ruby
require 'file_test_helper'
include FileTestHelper</p>

<p>def test_some_code_that_uses_the_file_system
  #Let's say that the current directory here is X</p>

<p>  with_files('dir1/file1' => 'file1 content', 'file2' => 'file2 content') do</p>

<pre><code>#Now the current directory changed to Y which is a new directory created under Dir.tmpdir containing only 'dir1/file1' and 'file2'

File.open('file2') do |f|
  #All filesystem operations are now scoped to the test directory
end
</code></pre>

<p>  end</p>

<p>  #When we finish we are back at directory X and the Y directory
  #is deleted with all its contents
end
```</p>

<p>Check the <a href="http://filetesthelper.rubyforge.org/specs.html">specs</a> for some more details.</p>
]]></content>
  </entry>
  
</feed>
