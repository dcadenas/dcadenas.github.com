---
layout: post
title: "My current template for extending ruby classes"
date: 2008-10-01T02:50:00-03:00
comments: false
categories:
 - Ruby
---

<div class='post'>
So obviously I like a lot the coding tips Jay Fields gives in his <a href="http://blog.jayfields.com">blog</a>. <br />I already summarized <a href="http://www.danielcadenas.com/2008/09/singleton-class-magic-without-using.html">here</a> one alternative he shows to the use of singleton classes.<br /><br />He has another good <a href="http://blog.jayfields.com/2008/04/alternatives-for-redefining-methods.html">article</a> that explains the problems of using <code>alias</code> and he shows some alternatives. The key of the prefered alternative is extending each instance so that <code>super</code> corresponds to the old method we want to replace.<br /><br />Both solutions share the same idea, they use the inheritance chain.<br />No aliasing, no singleton classes.<br />The advantages I see about this way of changing Ruby classes are:<br /><ul><br /><li>Visibility. You never lose track of the changes made, you can always find useful and simple hints through the object ancestors about where the extensions have been made. This improves maintenance and helps during debugging.<br /></li><br /><li>Simplicity. Singleton classes are a strange concept that smell like an implementation detail and we already know what an inheritance chain is and it gives the same results.<br />Also the concept of aliasing is not standard but we can gain at least the same benefits through <code>super</code>.<br /></li><br /><li>Uniformity. The code just looks nicer because you don't need to mix different techniques. Module extension does everything. Code that looks nicer is a serious thing, just think about indentation.<br /></li><br /></ul><br /><br />So after those articles convinced me about the benefits of respecting the inheritance chain I started to use this template whenever I want to change some class:<br /><br /><pre><br />module InstanceMethods<br />  def error_messages_for *args<br />    options = args.extract_options!<br />    options[:header_message] = 'No se llenaron correctamente los campos' unless options.has_key? :header_message<br />    options[:message] = 'Verifique los errores marcados en rojo' unless options.has_key? :message<br />    super *([args] << options)<br />  end<br />end<br /><br />module ClassMethods<br />  def new *args<br />    super.extend InstanceMethods<br />  end<br />end<br /><br />ActionView::Base.extend ClassMethods<br /></pre><br /><br />Notice that I put the instance extensions module nested inside the class extensions module. I feel this is intuitive as the extensions to an instance of a class are a subset of the extensions of the class as a whole.</div>
