<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reverse ajax | Daniel Cadenas]]></title>
  <link href="http://dcadenas.github.com/blog/categories/reverse-ajax/atom.xml" rel="self"/>
  <link href="http://dcadenas.github.com/"/>
  <updated>2012-03-18T03:42:20-03:00</updated>
  <id>http://dcadenas.github.com/</id>
  <author>
    <name><![CDATA[Daniel Cadenas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reverse Ajax and Prototype with Mongrel handlers]]></title>
    <link href="http://dcadenas.github.com/blog/2008/08/25/reverse-ajax-and-prototype/"/>
    <updated>2008-08-25T23:38:00-03:00</updated>
    <id>http://dcadenas.github.com/blog/2008/08/25/reverse-ajax-and-prototype</id>
    <content type="html"><![CDATA[<p>A common use of <a href="http://en.wikipedia.org/wiki/Reverse_Ajax">reverse Ajax or Comet</a> calls is having some piece of information in your webpage that you want to update as soon as some remote event triggers, always without polling. Let's make a little experiment to see how this works:</p>

<h2>Client side</h2>

<p>So you start a request, the web server waits for the event to happen, and finally, a while later, the response is sent back to the client. When this process ends, it's very common that you want to start it again. You want to have a continuous ajax call when the event is also continuous, when it can happen many times.
To deal with this, as I'm using <a href="http://www.prototypejs.org/">prototype</a>, I made this javascript routine to start listening for the event:</p>

<p>```javascript
function continuousAjaxCall(url, method, params, successCallback){
  waitingForResponse = false;
  function iteration(){</p>

<pre><code>if(!waitingForResponse){
  waitingForResponse = true;
  new Ajax.Request(url, 
   {
     method: method,
     parameters: params,
     onSuccess: theSuccessCallback
   });
}
</code></pre>

<p>  };</p>

<p>  function theSuccessCallback(transport){
   successCallback(transport.responseText);
   waitingForResponse = false;
  };</p>

<p>  return new PeriodicalExecuter(iteration, 1);
}
```</p>

<p>So now if you do:</p>

<p><code>javascript
continuousAjaxCall("/WebFacade/SomeWebService", "post", "taskid=" + taskNumber, callback);
</code></p>

<p>you will start listening to the web service in <code>/WebFacade/SomeWebService</code> using method post and with <code>taskid=taskNumber</code> as the http body parameter.
The callback is a routine that will be executed each time the event is triggered. For example we could do this to show the result from the web service:</p>

<p><code>javascript
function callback(responseText)
{
  alert(responseText);
}
</code></p>

<p>The routine returns a prototype <a href="http://www.prototypejs.org/api/periodicalExecuter"><code>PeriodicalExecuter</code></a> that you can use to stop listening:</p>

<p><code>javascript
pe = continuousAjaxCall(...
pe.stop()
</code></p>

<h2>Server side</h2>

<p>In the server side I have some <a href="/blog/2008/08/24/standalone-mongrel-handler-hello-world">Mongrel handlers</a> serving the client pages. The key here is the line sleep 1 until <code>@@submitted_value</code> that waits until some new value is submitted and <strong>only</strong> then responds to the ajax request:</p>

<p>```ruby
require 'rubygems'
require 'mongrel'
include Mongrel</p>

<p>@@submitted_value = nil</p>

<p>class ReverseAjaxHandler &lt; HttpHandler
  def process(request, response)</p>

<pre><code>response.start(200) do |head,out|
  head['content-type'] = 'text/html'
  sleep 1 until @@submitted_value
  out &lt;&lt; @@submitted_value
  @@submitted_value = nil
end
</code></pre>

<p>  end
end</p>

<p>class SendHandler &lt; HttpHandler
  def process(request, response)</p>

<pre><code>response.start(200) do |head,out|
  #Code that renders the "/send" page and sets the @@submitted_value
  #...  
  #...  
end
</code></pre>

<p>  end
end</p>

<p>h = HttpServer.new("0.0.0.0", "5000")
h.register("/wait", ReverseAjaxHandler.new)
h.register("/send", SendHandler.new)
h.register("/files", DirHandler.new('.'))
h.run.join
```</p>

<p>It's nice to have this as a Mongrel handler because it's simple, but keep in mind that this implementation was made just for the purpose of this example and it is not thread safe. I don't control the access to the global variable <code>@@submitted_value</code>.</p>

<p>The code for this article can be found <a href="http://dcadenas.googlepages.com/ReverseAjaxExperiment.zip">here</a>.</p>
]]></content>
  </entry>
  
</feed>
